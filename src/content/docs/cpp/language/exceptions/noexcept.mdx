---
title: "noexcept operator"
sidebar:
  order: 5
---

import { Decl, DeclDoc } from "@components/decl-doc";
import { Desc, DescList, DocLink } from '@components/index';
import { Revision, RevisionBlock } from "@components/revision";
import { DR, DRList } from "@components/defect-report";
import { ParamDoc, ParamDocList } from "@components/param-doc";

The `noexcept` operator performs a compile-time check that returns `true` if an expression is declared to not throw any exceptions.

It can be used within a function template's <DocLink dest="/cpp/language/exceptions/noexcept_spec">noexcept specifier</DocLink> to declare that the function will throw exceptions for some types but not others.

## Syntax

<DeclDoc>
  <Decl slot="decl">
  ```cpp cxx-mark
  noexcept(/*$s:expression*/)
  ```
  </Decl>
</DeclDoc>

Returns a <DocLink dest="/cpp/language/value_category#prvalue">prvalue</DocLink> of type `bool`. The result is `true` if <Revision until="C++17">the set of <DocLink dest="/cpp/language/exceptions/exception_specification/dynamic_specification" text="potential exceptions" /> of the _expression_ is empty</Revision><Revision since="C++17">_expression_ is specified to be <DocLink dest="/cpp/language/exceptions/exception_specification/noexcept_specification" text="non-throwing" /></Revision>, and `false` otherwise.

_expression_ is an <DocLink dest="/cpp/language/expressions#Potentially-evaluated_expressions">unevaluated operand</DocLink>.

<Revision since="C++17">If _expression_ is a prvalue, <DocLink dest="/cpp/language/implicit_cast#Temporary_materialization">temporary materialization</DocLink> is applied.</Revision>

## Notes

Even if `noexcept(expr)` is `true`, an evaluation of `expr` may still throw as the result of encountering undefined behavior.

<RevisionBlock since="C++17">
If _expression_ is of a class type or (possibly multidimensional) array thereof, temporary materialization requires the destructor be non-deleted and accessible.
</RevisionBlock>

## Keywords

*   <DocLink dest="/cpp/keywords/noexcept">`noexcept`</DocLink>

## Example

```cpp
#include <iostream>
#include <utility>
#include <vector>

void may_throw();
void no_throw() noexcept;
auto lmay_throw = []{};
auto lno_throw = []() noexcept {};

class T
{
public:
    ~T(){} // dtor prevents move ctor
           // copy ctor is noexcept
};

class U
{
public:
    ~U(){} // dtor prevents move ctor
           // copy ctor is noexcept(false)
    std::vector<int> v;
};

class V
{
public:
    std::vector<int> v;
};

int main()
{
    T t;
    U u;
    V v;

    std::cout << std::boolalpha <<
        "may_throw() is noexcept(" << noexcept(may_throw()) << ")\n"
        "no_throw() is noexcept(" << noexcept(no_throw()) << ")\n"
        "lmay_throw() is noexcept(" << noexcept(lmay_throw()) << ")\n"
        "lno_throw() is noexcept(" << noexcept(lno_throw()) << ")\n"
        "~T() is noexcept(" << noexcept(std::declval<T>().~T()) << ")\n"
        // note: the following tests also require that ~T() is noexcept because
        // the expression within noexcept constructs and destroys a temporary
        "T(rvalue T) is noexcept(" << noexcept(T(std::declval<T>())) << ")\n"
        "T(lvalue T) is noexcept(" << noexcept(T(t)) << ")\n"
        "U(rvalue U) is noexcept(" << noexcept(U(std::declval<U>())) << ")\n"
        "U(lvalue U) is noexcept(" << noexcept(U(u)) << ")\n"
        "V(rvalue V) is noexcept(" << noexcept(V(std::declval<V>())) << ")\n"
        "V(lvalue V) is noexcept(" << noexcept(V(v)) << ")\n";
}
```

Output:

```text
may_throw() is noexcept(false)
no_throw() is noexcept(true)
lmay_throw() is noexcept(false)
lno_throw() is noexcept(true)
~T() is noexcept(true)
T(rvalue T) is noexcept(true)
T(lvalue T) is noexcept(true)
U(rvalue U) is noexcept(false)
U(lvalue U) is noexcept(false)
V(rvalue V) is noexcept(true)
V(lvalue V) is noexcept(false)
```

## Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.

<DRList>
<DR kind="cwg" id={2722} std="C++17">
  <Fragment slot="behavior-published">
    it was unclear whether temporary materialization is applied if _expression_ is a prvalue
  </Fragment>
  <Fragment slot="correct-behavior">
    it is applied in this case 
  </Fragment>
</DR>
<DR kind="cwg" id={2792} std="C++11">
  <Fragment slot="behavior-published">
    the `noexcept` operator was required to determine whether exceptions may be thrown in the case of encountering undefined behavior
  </Fragment>
  <Fragment slot="correct-behavior">
    not required 
  </Fragment>
</DR>
</DRList>

## See also

<DescList>
  <Desc>
    <DocLink slot="item" dest="/cpp/language/exceptions/noexcept_spec">noexcept specifier<Revision since="C++11"/></DocLink>
    *   specifies whether a function could throw exceptions
  </Desc>
  <Desc>
    <DocLink slot="item" dest="/cpp/language/exceptions/exception_spec">Dynamic exception specification<Revision until="C++17"/></DocLink>
    *   specifies what exceptions are thrown by a function<Revision traits={[{ trait: "deprecated", since: "C++26" }]}/>
  </Desc>
</DescList>